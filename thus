program 1: Design and develop a program to perform array operations. 
a. Creating an array 
 b. Display of array Elements 
 c. Inserting an Element at a given Position 
d. Deleting an Element at a given Position 
 
 #include<stdio.h>
#include<stdlib.h>
int i,a[50],n=0,POS,ELEM;
void create();
void display();
int insert();
int del();
int main()
{
int choice;
//clrscr();
do
{
printf("\n\n---MENU---");
printf("\n 1.Create");
printf("\n 2.Display");
printf("\n 3.Insert");
printf("\n 4.delete");
printf("\n 5.Exit");
printf("\nEnter your choice:\t");
scanf("%d",&choice);
switch(choice)
{
case 1: create();
break;
case 2: display();
break;
case 3: if (n==0)
{
printf ("\tArray is empty ");
}
else
{
insert();
}
break;
case 4: if (n==0)

Department of CSD, DSCE Page 
{
printf ("\tArray is empty ");
}
else
{
del();
}
break;
case 5: exit(0);
break;
default : printf("\tInvalid Chioce");
}
}while(choice!=5);
return 0;
}
void create()
{
printf("Enter the number of elements:\t");
scanf("%d",&n);
printf("\nEnter the array elements");
for(i=0;i<n;i++)
{
scanf("%d",&a[i]);
}
}
void display()
{
if(n==0)
{
printf("\tArray is empty ");
}
else
{
printf("Array elements are \n");
for(i=0;i<n;i++)
{
printf("%d\t",a[i]);
}
}
}
int insert()
{
printf("Enter the location where you wish to insert an element:\t"); 
scanf("%d",&POS);

if(POS==0 || POS>n+1)
{
printf("Insertion is not possible 'POS>N'");
}
else
{
printf("\nEnter the value to Insert: \t");
scanf("%d",&ELEM);
for(i=n-1;i>=POS-1;i--)
{
a[i+1]=a[i];
}
a[POS-1]=ELEM;
n++;
}
return 0;
}
int del()
{
printf("Enter the location where you wish to delete element:\t");
scanf("%d",&POS);
if(POS==0 || POS>=n+1)
{
printf("\nDeletion is not possible 'POS>N'");
}
else
{
printf("\nDeleted Item is = %d\n",a[POS-1]);
for(i=POS-1;i<n;i++)
{
a[i]=a[i+1];
}
n--;
}
return 0;
} 

Program 2: Design and develop a program working of stack using array
 Push
 Pop
 Display
 Demonstrate overflow and underflow
#include<stdio.h>
#include<stdlib.h>
#define MAX_SIZE 4
int stk[MAX_SIZE], top=-1;
void push();
void pop();
void display();
void main()
{
int choice;
while(1)
{
printf("\n\n---MENU---");
printf("\n1.Push");
printf("\n2.Pop");
printf("\n3.Display");
printf("\n4.exit");
printf("\nEnter your choice:\t");
scanf("%d",&choice); //Read Choice
switch(choice)
{
case 1: push();
break;
case 2: pop();
break;
case 3: display();
break;
case 4: exit(0);
break;
default :printf("\tInvalid Chioce");
}
}
}
void push()
{
int p;

if(top==MAX_SIZE-1)
{
printf("Stack Overflow");
}
else
{
printf("Enter the Element to Push\n");
scanf("%d",&p);
top++;
stk[top]=p;
}
}
void pop()
{
if(top==-1)
{
printf("Stack Underflow");
}
else
{
printf("Poped element is %d",stk[top]);
top--;
}
}
void display()
{
int i;
if(top== -1)
{
printf("Stack is Empty");
}
else
{
printf("Elements in STACK are \n");
for(i=0;i<=top;i++)
{
printf("%d\t",stk[i]);
}
}
}

Program 3: Design and develop a Program for converting an Infix Expression to Postfix 
 Expression. The expression should consist operators: +, -, *, /, % (Remainder), 
#include<stdio.h>
#include<string.h>
#include<conio.h>
int F(char symbol)
{
switch(symbol)
{
case '+':
case '-': return 2;
case '*':
case '/':
case '%': return 4;
case '^':
case '$': return 5;
case '(': return 0;
case '#': return -1;
default: return 8;
}
}
int G(char symbol)
{
switch(symbol)
{
case '+':
case '-': return 1;
case '*':
case '/':
case '%': return 3;
case '^':
case '$': return 6;
case '(': return 9;
case ')': return 0;
default: return 7;
}
}
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
void infix_postfix(char infix[],char postfix[])
{
int top, i, j;
char symbol, s[30];
top--;
s[++top]= '#';
j=0;
for(i=0;i<strlen(infix);i++)
{
symbol=infix[i];
while(F(s[top])>G(symbol))
{
postfix[j++]=s[top--];
}
if(F(s[top])!=G(symbol))
s[++top]=symbol;
else
top--;
}
while(s[top]!= '#')
{
postfix[j++]=s[top--];
}
postfix[j]='\0';
}
void main()
{
char infix[20],postfix[20];
//clrscr();
printf("Enter the Infix Expression :\n");
scanf("%s",infix);
infix_postfix(infix,postfix);
printf("The Post Expression is:\n");
printf("%s\n",postfix);
getch();
}
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
Program 4: Design and Develop a program working of queue 
 a. Insert
 b. Delete
 c. Display 
 d. Demonstrate queue empty and queue overflow 
#include<stdio.h>
#include<conio.h>
#define MAXSIZE 5
int f=-1,r=-1,q[MAXSIZE];
void insert()
{
int item;
if(r==MAXSIZE-1)
printf("OVERFLOW!!!");
else
 {
if(f==-1)
 f=0;
printf("Enter the items to be inserted:\n");
scanf("%d",&item);
q[++r]=item;
 }
}
void delete()
{
if(f==-1)
printf("UNDERFLOW!!!");
else if(f>r)
 {
 f=r=-1;
printf("UNDERFLOW!!!");
 }
else
printf("item deleted=%d",q[f++]);
}
void display()
{
int i ;
if(f==-1)
printf("UNDERFLOW!!!");
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
else
 {
printf("The elements are: \n");
for(i=f;i<=r;i++)
printf("%d ",q[i]);
 }
}
void main()
{
int ch;
for(;;)
 {
printf("\n1:INSERT\n2:DELETE\n3:DISPLAY\n4:EXIT\n");
scanf("%d",&ch);
switch(ch)
 {
case 1:printf("INSERTION\n");
insert();
break;
case 2:printf("DELETION\n");
delete();
break;
case 3:printf("DISPLAY\n");
display();
break;
default : exit(0); 
 }
 }
}
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
Program 5: Design and Develop a program working of circular queue 
 a. Insert
 b. Delete
 c. Display 
 d. Demonstrate queue empty and queue overflow
#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
#define SIZE 5
int item,queue[SIZE];
int front=-1,rear=-1;
int qfull()
{
if(front==(rear+1)%SIZE)
return 1;
else
return 0;
}
int qempty()
{
if(front==-1)
return 1;
else
return 0;
}
void add()
{
if(qfull())
printf("\n The Circular Queue is Full\n");
else
{
printf("\n Enter the Element\t:");
scanf("%d",&item);
if(front==-1)
front=rear=0;
else
rear=(rear+1)%SIZE;
queue[rear]=item;
}
}
void del()
{
if(qempty())
printf("\n Queue is Empty\n");
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
else
{
item=queue[front];
if(front==rear)
front=rear=rear=-1;
else
front=(front+1)%SIZE;
printf("\n The Deleted Item is %d",item);
}
}
void display()
{
int i;
if(qempty())
{
printf("\n The Queue is Empty\n");
return ;
}
i=front;
while(i!=rear)
{
printf("%d\t",queue[i]);
i=(i+1)%SIZE;
}
printf("%d\t",queue[i]);
}
void main(void)
{
int choice;
for(;;)
{
printf("\n Main Menu");
printf("\n1.Insert\n2.Delete\n3.Display\n4.Exit");
printf("\n Enter Your Choice\t:");
scanf("%d",&choice);
switch(choice)
{
case 1: add();
break;
case 2: del();
break;
case 3: display();
break;
case 4: exit(0);
break;
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
default: printf("Invalid Choice");
}
}
getch();
}
Program 6: Design and Develop a program to demonstrate working of singly linked list
 a) Create a linked list.
 b) Insertion and deletion of a node at first position and at end position. 
 c) Display the contents of the linked list.
#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
struct node
{
int info;
struct node *link;
};
struct node* NODE;
NODE getnode()
{
 NODE x;
 x=(NODE)malloc(sizeof(struct node));
if(x==NULL)
{ 
printf("out of memory\n");
exit(0);
 }
return x;
}
void freenode(NODE x)
{
free(x);
}
NODE insert_front(int item, NODE first)
{
 NODE temp;
temp=getnode();
temp->info=item;
temp->link=first;
return temp;
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
} 
NODE delete_front(NODE first)
{
 NODE temp;
if(first==NULL)
 {
printf("Link is empty\n");
return first;
 }
temp=first;
first=first->link;
printf("The deleted item is %d \n",temp->info);
free(temp);
return first;
}
NODE insert_rear(int item,NODE first)
{
 NODE temp,cur;
temp=getnode();
temp->info=item;
temp->link=NULL;
if(first==NULL)
return temp;
cur=first;
while(cur->link!=NULL)
 {
cur=cur->link;
 }
cur->link=temp;
return first;
}
NODE delete_rear(NODE first)
{
 NODE cur=first, prev=NULL;
if(cur==NULL)
 {
printf("Link is empty\n");
return first;
 }
while(cur->link!=NULL)
 {
prev=cur;
cur=cur->link;
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
 }
freenode(cur);
prev->link=NULL;
return first;
}
void display(NODE first)
{ NODE temp=first;
if(first==NULL)
 {
printf("NO NODES IN THE LIST!!\n");
return first; 
 }
else
 {
while(temp!=NULL)
 {
printf("%d ",temp->info);
temp=temp->link;
 }
 }
}
void main()
{
 NODE first=NULL;
int choice, item;
//clrscr();
for(;;)
 {
printf("\n1.INSERT FRONT\n2.INSERT REAR\n3.DELETE FRONT\n4.DELETE 
REAR\n5.DISPLAY\n");
scanf("%d",&choice);
switch(choice)
 {
case 1:printf("Enter the item\n");
scanf("%d",&item);
first=insert_front(item,first);
break;
case 2:printf("Enter the item\n");
scanf("%d",&item);
first=insert_rear(item,first);
break;
case 3:first=delete_front(first);
break;
case 4:first=delete_rear(first);
break;
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
case 5:display(first);
break;
default:exit(0); 
 }
 }
}
Program 7: Design, Develop and Implement a Program in C to evaluate a polynomial 
expression using singly Circular Linked List (SCLL) with header nodes. 
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
int flag;
struct node
{
int cf;
int px,py,pz;
struct node *link;
};
typedef struct node *NODE;
NODE get_node()
{
NODE x;
x=(struct node*)malloc(sizeof(struct node));
if(x==NULL)
{
printf("Out of Memory\n");
exit(0);
}
return x;
}
NODE insert_rear(int cf,int x,int y,int z,NODE head)
{
NODE temp,cur;
temp=get_node();
temp->cf=cf;
temp->px=x;
temp->py=y;
temp->pz=z;
cur=head->link;
while(cur->link!=head)
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
cur=cur->link;
cur->link=temp;
temp->link=head;
return head;
}
NODE read_poly(NODE head)
{
int i;
int px,py,pz;
int cf;
printf("\nEnter the coef as -999 to End the Polynomial");
for(i=1;;i++)
{
printf("\nEnter the %d Term",i);
printf("Coef=");
scanf("%d",&cf);
if(cf==-999)
break;
printf("Pow x=");
scanf("%d",&px);
printf("Pow y=");
scanf("%d",&py);
printf("Pow z=");
scanf("%d",&pz);
head=insert_rear(cf,px,py,pz,head);
}
return head;
}
int evaluate(NODE head)
{
int x,y,z,sum=0;
NODE poly;
printf("Enter the Value of x, y and z");
scanf("%d%d%d",&x,&y,&z);
poly=head->link;
while(poly!=head)
{
sum+=poly->cf*pow(x,poly->px)*pow(y,poly->py)*pow(z,poly->pz); 
poly=poly->link;
}
return sum;
}
void display(NODE head)
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
{
NODE temp;
if(head->link==head)
{
printf("\nPoly Does not Exist\n");
return;
}
temp=head->link;
while(temp!=head)
{
printf("+%dx^%dy^%dz^%d",temp->cf,temp->px,temp->py,temp->pz); 
temp=temp->link;
}
printf("\n");
}
void main()
{
NODE h1,h2,h3,head;
int sum;
int ch;
//clrscr();
head=get_node();
head->link=head;
h1=get_node();
h2=get_node();
h3=get_node();
h1->link=h1;
h2->link=h2;
h3->link=h3;
for(;;)
{
printf("1:Read Polynomial\n2:Evaluate\n3:Display\n4:Exit\n");
printf("Enter The Choice:\t");
scanf("%d",&ch);
switch(ch)
{
case 1: printf("Enter The Polynomial\n");
head=read_poly(head);
break;
case 2: sum=evaluate(head);
printf("The Given Polynomial is\n");
display(head);
printf("The Result=%d\n",sum);
break;
case 3: printf("The Given Polynomial is \n");
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
display(head);
break;
case 4: printf("Enter The First Poly\n");
h1=read_poly(h1);
printf("Enter The Second Poly\n");
h2=read_poly(h2);
//h3=add_poly(h1,h2,h3);
printf("The First Poly is\n");
display(h1);
printf("The Sec Poly is\n");
display(h2);
printf("Sum of Two Poly is \n");
display(h3);
break;
case 5: exit(0);
break;
default:printf("Invalid Choice\n");
}
}
}
Program 8: Design and Develop a program to demonstrate working of doubly linked list a) 
Create a linked list. b) Insertion and deletion of a node at first position, at any position and 
at end position. c) Display the contents of the linked list. 
#include<stdio.h>
#include<stdlib.h>
struct node
{
 int info;
 struct node *llink;
 struct node *rlink;
};
struct node *first, *cur, *prev, *next;
void insertfront()
{
 struct node *temp;
 temp = (struct node*)malloc(sizeof(struct node));
 temp->llink = temp->rlink= NULL;
 printf("enter the node to be inserted \n");
 scanf("%d",&temp->info);
 if(first == NULL)
 {
 first=temp;
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
 return;
 }
 temp->rlink=first;
 first->llink=temp;
 first=temp;
}
void insertleft()
{
 int key;
 struct node *temp;
 temp = (struct node*)malloc(sizeof(struct node));
 temp->llink = temp->rlink = NULL;
 if(first==NULL)
 {
 printf("list is empty \n");
 return;
 }
 printf("enter the key before which node is to be inserted \n");
 scanf("%d",&key);
 printf("enter the node to be inserted \n");
 scanf("%d",&temp->info);
 prev=NULL;
 cur=first;
 while(cur!=NULL)
 {
 if(cur->info==key && cur==first)
 {
 temp->rlink=cur;
 cur->llink=temp;
 first=temp;
 return;
 }
 if(cur->info==key)
 {
 temp->rlink=cur;
 cur->llink=temp;
 temp->llink=prev;
 prev->rlink=temp;
 return;
 }
 prev=cur;
 cur=cur->rlink;
 }
 printf("key not found");
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
}
void Delete1()
{
 int key;
 printf("enter the node to be deleted \n");
 scanf("%d", &key);
 if(first==NULL)
 {
 printf("list is empty \n");
 return;
 }
 if(first->rlink==NULL)
 {
 if(key==first->info)
 {
 printf("%d node is deleted", key);
 free(first);
 first = NULL;
 return;
 }
else
 {
 printf("key not found \n");
 return;
 }
 }
 cur=first;
 while(cur!=NULL)
 {
 if (cur->info==key)
 {
 if(cur==first)
 {
 first=first->rlink;
 printf("%d node is deleted", key);
 free(cur);
 return;
 }
 
 if(cur->rlink==NULL)
 {
 prev=cur->llink;
 prev->rlink=NULL;
 printf("%d node is deleted \n", key);
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
 free(cur);
 return;
 }
 prev=cur->llink;
 next=cur->rlink;
 prev->rlink=next;
 next->llink=prev;
 printf("%d node is deleted \n", key);
 free(cur);
 return;
 }
 cur=cur->rlink;
 }
 printf("key not found \n");
}
void display()
{
 cur=NULL;
 if(first==NULL)
 {
 printf("list is empty \n");
 return;
 }
 printf("list is: \n");
 cur=first;
 while(cur!=NULL)
 {
 printf("%d \t", cur->info);
 cur=cur->rlink;
 }
}
int main()
{
 int ch;
printf("enter 1.insert at front \n 2.insert before a node \n 3.delete at node\n 
4.display\n");
 for(;;)
 {
 printf("\n enter the choice");
 scanf("%d", &ch);
 switch(ch)
 {
 case 1: insertfront();
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
 break;
 case 2: insertleft();
 break;
 case 3: Delete1();
 break;
 case 4: display();
 break;
 default : exit(0);
 }
 }
}
Program 9: Design and Develop a program for the following operations on Binary Search 
 Tree (BST) of Integers. a. Create a BST b. display c. Traverse the BST in 
 Inorder, Preorder and Post Order d. Search the BST for a given KEY 
 element.
#include<stdio.h>
#include<stdlib.h>
struct node
{
int info;
struct node *llink;
struct node *rlink;
};
typedef struct node *NODE;
void insert();
void preorder();
void postorder();
void inorder();
void search();
void main()
{
int ch,res=1,key;
NODE temp,root;
NODE get_node();
//clrscr();
root=NULL;
printf("\nProgram for BST\n");
for(;;)
{
printf("\n1:Insert\n2:Search\n3:Traversal\n4:Exit");
printf("\nEnter The Choice:\t");
scanf("%d",&ch);
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
switch(ch)
{
case 1: do
{
temp=get_node();
printf("\nEnter Element:\t");
scanf("%d",&temp->info);
if(root==NULL)
root=temp;
else
insert(root,temp);
printf("\nDo you Want To Insert Next..?(1|0):\t"); 
scanf("%d",&res);
}while(res);
break;
case 2: printf("\nEnter The Element to be Search:\t"); 
scanf("%d",&key);
search(root,key);
break;
case 3: if(root==NULL)
printf("\nTree is not Created");
else
{
printf("\nThe Inorder Traversal\n");
inorder(root);
printf("\nThe Preorder Traversal\n");
preorder(root);
printf("\nThe Postorder Traversal\n");
postorder(root);
}
break;
case 4:exit(0);
 break;
}
}
}
NODE get_node()
{
NODE temp;
temp=(struct node*)malloc(sizeof(struct node));
temp->llink=NULL;
temp->rlink=NULL;
return temp;
}
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
void insert(NODE root,NODE temp)
{
if(temp->info<root->info)
{
if(root->llink==NULL)
root->llink=temp;
else
insert(root->llink,temp);
}
if(temp->info > root->info)
{
if(root->rlink==NULL)
root->rlink=temp;
else
insert(root->rlink,temp);
}
}
void search(NODE root,int key)
{
if(root==NULL)
printf("Search Unsuccessful\n");
else if(key==root->info)
printf("Search Success Item %d Found",key); 
else if(key<root->info)
search(root->llink,key);
else
search(root->rlink,key);
}
void inorder(NODE temp)
{
if(temp!=NULL)
{
inorder(temp->llink);
printf("%d\t",temp->info);
inorder(temp->rlink);
}
}
void preorder(NODE temp)
{
if(temp!=NULL)
{
printf("%d\t",temp->info);
preorder(temp->llink);
Data Structures and Applications with Lab using C (21IPCCCG32)
Department of CSD, DSCE Page 
preorder(temp->rlink);
}
}
void postorder(NODE temp)
{
if(temp!=NULL)
{
postorder(temp->llink); 
postorder(temp->rlink); 
printf("%d\t",temp->info);
}
}
